{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"configuration/","text":"Configuration You can use JSON, YAML or INI files to configure PhpMetrics, with the `--config= option. Full example a configuration file: --- composer : false # Analyse the composer.* files includes : # directory and files to analyze, relative to config file directory - \"src\" excludes : # regex of files (or directory) to exclude from analyze - tests extensions : # default: [\"php\", \"inc\"] - php - php8 report : # list of reports to generate html : \"/tmp/report/\" csv : \"/tmp/report.csv\" json : \"/tmp/report.json\" violations : \"/tmp/violations.xml\" # \"layers\" of code. You can group your classes and packages by regex, # to visualise specific HTML report for each of them groups : - name : Component match : \"!component!i\" # regex to match the group - name : Hexagon match : \"!hexagon!i\" plugins : git : binary : git # if defined, runs git analyze junit : file : \"/tmp/junit.xml\" # if defined, analyze junit report # You can define patterns of code to search # That's useful for Continuous Integration searches : Repository which uses Service : # You can name your search as you want type : class instanceOf : - App\\MyRepository nameMatches : \".*Repository.*\" usesClasses : - \".*Service\" failIfFound : true # stop execution if pattern of code is found Class with too complex code : type : class ccn : \">=10\" failIfFound : true Class with too many responsabilitites : type : class lcom : \">=3\" failIfFound : true Controller which use doctrine : type : class nameMatches : \".*Controller.*\" usesClasses : - \".*Connection.*\" failIfFound : true","title":"Configuration"},{"location":"configuration/#configuration","text":"You can use JSON, YAML or INI files to configure PhpMetrics, with the `--config= option. Full example a configuration file: --- composer : false # Analyse the composer.* files includes : # directory and files to analyze, relative to config file directory - \"src\" excludes : # regex of files (or directory) to exclude from analyze - tests extensions : # default: [\"php\", \"inc\"] - php - php8 report : # list of reports to generate html : \"/tmp/report/\" csv : \"/tmp/report.csv\" json : \"/tmp/report.json\" violations : \"/tmp/violations.xml\" # \"layers\" of code. You can group your classes and packages by regex, # to visualise specific HTML report for each of them groups : - name : Component match : \"!component!i\" # regex to match the group - name : Hexagon match : \"!hexagon!i\" plugins : git : binary : git # if defined, runs git analyze junit : file : \"/tmp/junit.xml\" # if defined, analyze junit report # You can define patterns of code to search # That's useful for Continuous Integration searches : Repository which uses Service : # You can name your search as you want type : class instanceOf : - App\\MyRepository nameMatches : \".*Repository.*\" usesClasses : - \".*Service\" failIfFound : true # stop execution if pattern of code is found Class with too complex code : type : class ccn : \">=10\" failIfFound : true Class with too many responsabilitites : type : class lcom : \">=3\" failIfFound : true Controller which use doctrine : type : class nameMatches : \".*Controller.*\" usesClasses : - \".*Connection.*\" failIfFound : true","title":"Configuration"},{"location":"continuous-integration/","text":"","title":"Continuous integration"},{"location":"getting-started/","text":"Quick Start Installation Choose your favorite method: Composer Docker Phar Apt (Debian, Ubuntu...) Brew (OSX) PhpArch composer global require 'phpmetrics/phpmetrics' Please note that the ~/.composer/vendor/bin directory must be in your $PATH. For example in your ~/.bash_profile (or ~/.bashrc), add : export PATH = ~/.composer/vendor/bin: $PATH docker run --rm --volume ` pwd ` :/project herloct/phpmetrics [ <options> ] curl -L \"https://github.com/phpmetrics/PhpMetrics/blob/master/releases/phpmetrics.phar?raw=true\" -o phpmetrics.phar chmod +x phpmetrics.phar && mv phpmetrics.phar /usr/local/bin/phpmetrics curl -L \"https://github.com/phpmetrics/PhpMetrics/blob/master/releases/phpmetrics.deb?raw=true\" -o phpmetrics.deb dpkg -i phpmetrics.deb brew install phpmetrics yaourt install phpmetrics Usage Run PHPMetrics with the following command: php ./vendor/bin/phpmetrics --report-html = myreport <folder-to-analyze> You'll get a CLI output with summary of analysis, and detailled report in myreport/index.html file. Configuration You can use a configuration file to use advanced features (like continuous integration, searches and more). Create a config.yml file in the root of your project (you can also use JSON or INI files if you want). --- includes : - \"src\" report : html : \"/tmp/report/\" json : \"/tmp/report.json\" violations : \"/tmp/violations.xml\" plugins : git : binary : git Continuous integration You can search for patterns in your code, with the searches configuration. Enable the failIfFound flag to fail your build if a pattern is found. For example, if you want to fail if a Repository uses a Service, or if you have to complexe code: ... searches : Repository which uses Service : type : class instanceOf : - App\\MyRepository nameMatches : \".*Repository.*\" usesClasses : - \".*Service\" failIfFound : true Class with too complex code : type : class ccn : \">=10\" failIfFound : true Groups of code Sometimes you want to analyze a group of code (for example your controllers). You can do this with the groups configuration. ... groups : - name : Component match : \"!component!i\" - name : Controller match : \"!controller!i\"","title":"Quick Start"},{"location":"getting-started/#quick-start","text":"","title":"Quick Start"},{"location":"getting-started/#installation","text":"Choose your favorite method: Composer Docker Phar Apt (Debian, Ubuntu...) Brew (OSX) PhpArch composer global require 'phpmetrics/phpmetrics' Please note that the ~/.composer/vendor/bin directory must be in your $PATH. For example in your ~/.bash_profile (or ~/.bashrc), add : export PATH = ~/.composer/vendor/bin: $PATH docker run --rm --volume ` pwd ` :/project herloct/phpmetrics [ <options> ] curl -L \"https://github.com/phpmetrics/PhpMetrics/blob/master/releases/phpmetrics.phar?raw=true\" -o phpmetrics.phar chmod +x phpmetrics.phar && mv phpmetrics.phar /usr/local/bin/phpmetrics curl -L \"https://github.com/phpmetrics/PhpMetrics/blob/master/releases/phpmetrics.deb?raw=true\" -o phpmetrics.deb dpkg -i phpmetrics.deb brew install phpmetrics yaourt install phpmetrics","title":"Installation"},{"location":"getting-started/#usage","text":"Run PHPMetrics with the following command: php ./vendor/bin/phpmetrics --report-html = myreport <folder-to-analyze> You'll get a CLI output with summary of analysis, and detailled report in myreport/index.html file.","title":"Usage"},{"location":"getting-started/#configuration","text":"You can use a configuration file to use advanced features (like continuous integration, searches and more). Create a config.yml file in the root of your project (you can also use JSON or INI files if you want). --- includes : - \"src\" report : html : \"/tmp/report/\" json : \"/tmp/report.json\" violations : \"/tmp/violations.xml\" plugins : git : binary : git","title":"Configuration"},{"location":"getting-started/#continuous-integration","text":"You can search for patterns in your code, with the searches configuration. Enable the failIfFound flag to fail your build if a pattern is found. For example, if you want to fail if a Repository uses a Service, or if you have to complexe code: ... searches : Repository which uses Service : type : class instanceOf : - App\\MyRepository nameMatches : \".*Repository.*\" usesClasses : - \".*Service\" failIfFound : true Class with too complex code : type : class ccn : \">=10\" failIfFound : true","title":"Continuous integration"},{"location":"getting-started/#groups-of-code","text":"Sometimes you want to analyze a group of code (for example your controllers). You can do this with the groups configuration. ... groups : - name : Component match : \"!component!i\" - name : Controller match : \"!controller!i\"","title":"Groups of code"},{"location":"installation/","text":"Composer Docker Phar Apt (Debian, Ubuntu...) Brew (OSX) PhpArch composer global require 'phpmetrics/phpmetrics' Please note that the ~/.composer/vendor/bin directory must be in your $PATH. For example in your ~/.bash_profile (or ~/.bashrc), add : export PATH = ~/.composer/vendor/bin: $PATH docker run --rm --volume ` pwd ` :/project herloct/phpmetrics [ <options> ] curl https://github.com/phpmetrics/PhpMetrics/releases/download/v2.7.3/phpmetrics.phar chmod +x phpmetrics.phar && mv phpmetrics.phar /usr/local/bin/phpmetrics curl https://github.com/phpmetrics/PhpMetrics/releases/download/v2.7.4/phpmetrics.deb dpkg -i phpmetrics.deb brew install phpmetrics yaourt install phpmetrics","title":"Installation"},{"location":"license/","text":"MIT License The MIT License (MIT) Copyright (c) 2013 Jean-Fran\u00e7ois L\u00e9pine https://twitter.com/Halleck45 http://blog.lepine.pro Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#mit-license","text":"The MIT License (MIT) Copyright (c) 2013 Jean-Fran\u00e7ois L\u00e9pine https://twitter.com/Halleck45 http://blog.lepine.pro Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT License"},{"location":"metrics/","text":"Main metrics Halstead complexity measures Metrics: length , vocabulary , volume , difficulty , effort , level , bugs , time , intelligentContent , number_operators , number_operands , number_operators_unique , number_operands_unique \\(n1\\) = the number of distinct operators \\(n2\\) = the number of distinct operands \\(N1\\) = the total number of operators \\(N2\\) = the total number of operands From these numbers, eight measures can be calculated: Program vocabulary: \\(n = n1 + n2\\) Program length: \\(N = N1 + N2\\) Calculated program length: \\(N' = n1 * log2(n1) + n2 * log2(n2)\\) Volume: \\(V = N * log2(n)\\) Difficulty: \\(D = (n1/2) * (N2/n2)\\) Effort: \\(E = D * V\\) Time required to program: \\(T = E / 18 seconds\\) Number of delivered bugs: \\(B = V / 3000\\) Note https://en.wikipedia.org/wiki/Halstead_complexity_measures https://www.verifysoft.com/en_halstead_metrics.html Cyclomatic complexity number and weighted method count Metrics: wmc , ccn , ccnMethodMax The cyclomatic complexity ( \\(CCN\\) ) is a measure of control structure complexity of a function or procedure. We can calculate ccn in two ways (we choose the second): \\[ (CCN) = E - N + 2P \\] Where: \\(P\\) = number of disconnected parts of the flow graph (e.g. a calling program and a subroutine) \\(E\\) = number of edges (transfers of control) \\(N\\) = number of nodes (sequential group of statements containing only one transfer of control) OR \\(CCN\\) = Number of each decision point The weighted method count ( \\(WMC\\) ) is count of methods parameterized by a algorithm to compute the weight of a method. Given a weight metric \\(w\\) and methods \\(m\\) it can be computed as sum m(w') over (w' in w) Possible algorithms are: Cyclomatic Complexity Lines of Code 1 (unweighted WMC) This visitor provides two metrics, the maximal CCN of all methods from one class (currently stored as ccnMethodMax) and the WMC using the CCN as weight metric (currently stored as ccn). Note https://en.wikipedia.org/wiki/Cyclomatic_complexity http://www.literateprogramming.com/mccabe.pdf https://www.pitt.edu/~ckemerer/CK%20research%20papers/MetricForOOD_ChidamberKemerer94.pdf Kan's defects Metrics: kanDefect \\(kanDefect = 0.15 + 0.23\\) * number of do\u2026while() + $0.22 $ * number of switch() + \\(0.07\\) * number of if() Maintainability Index Metrics: mi , mIwoC , commentWeight According to Wikipedia, \"Maintainability Index is a software metric which measures how maintainable (easy to support and change) the source code is. The maintainability index is calculated as a factored formula consisting of Lines Of Code, Cyclomatic Complexity and Halstead volume.\" \\(mIwoC\\) : Maintainability Index without comments \\(MIcw\\) : Maintainability Index comment weight$ \\(mi\\) : Maintainability Index = \\(mi = MIwoc + MIcw\\) \\(MIwoc = 171 - 5.2 * ln(aveV) -0.23 * aveG -16.2 * ln(aveLOC)\\) \\(MIcw** = 50 * sin(sqrt(2.4 * perCM))\\) \\(mi = MIwoc + MIcw\\) Note https://www.verifysoft.com/en_maintainability.html Lack of cohesion of methods Metrics: lcom Cohesion metrics measure how well the methods of a class are related to each other. A cohesive class performs one function while a non-cohesive class performs two or more unrelated functions. A non-cohesive class may need to be restructured into two or more smaller classes. High cohesion is desirable since it promotes encapsulation. As a drawback, a highly cohesive class has high coupling between the methods of the class, which in turn indicates high testing effort for that class. Low cohesion indicates inappropriate design and high complexity. It has also been found to indicate a high likelihood of errors. The class should probably be split into two or more smaller classes. Note https://blog.ndepend.com/lack-of-cohesion-methods/ http://www.arisa.se/compendium/node116.html Card and Agresti metric Metrics: relativeStructuralComplexity , relativeDataComplexity , relativeSystemComplexity , totalStructuralComplexity , totalDataComplexity , totalSystemComplexity \\(Fan-out\\) = Structural fan-out = Number of other procedures this procedure calls \\(v\\) = number of input/output variables for a procedure ( \\(SC\\) ) Structural complexity \\(SC = fan-out^2\\) ( \\(DC\\) ) Data complexity \\(DC = v / (fan-out + 1)\\) Note https://www.witpress.com/Secure/elibrary/papers/SQM94/SQM94024FU.pdf Length Metrics: cloc , loc , lloc \\(loc\\) : lines count \\(cloc\\) : lines count without multiline comments \\(lloc\\) : lines count without empty lines Methods Metrics : nbMethodsIncludingGettersSetters , nbMethods , nbMethodsPrivate , nbMethodsPublic , nbMethodsGetter , nbMethodsSetters Coupling Metrics: afferentCoupling , efferentCoupling , instability Afferent couplings ($Ca): The number of classes in other packages that depend upon classes within the package is an indicator of the package's responsibility. Efferent couplings ( \\(Ce\\) ): The number of classes in other packages that the classes in a package depend upon is an indicator of the package's dependence on externalities. Instability ( \\(I\\) ): The ratio of efferent coupling ( \\(Ce\\) ) to total coupling ( \\(Ce + Ca\\) ) such that \\(I = Ce / (Ce + Ca)\\) . Note https://www.future-processing.pl/blog/object-oriented-metrics-by-robert-martin/ https://en.wikipedia.org/wiki/Software_package_metrics Depth of inheritance tree Metrics: depthOfInheritanceTree Measures the length of inheritance from a class up to the root class. Page rank Metrics: pageRank The first version of the PageRank algorithm was developed by Larry Page and Sergey Brin in 1998. The algorithm is used to rank web pages according to their importance. We applied the PageRank algorithm to the case of relationships between packages and classes.","title":"Metrics"},{"location":"metrics/#main-metrics","text":"","title":"Main metrics"},{"location":"metrics/#halstead-complexity-measures","text":"Metrics: length , vocabulary , volume , difficulty , effort , level , bugs , time , intelligentContent , number_operators , number_operands , number_operators_unique , number_operands_unique \\(n1\\) = the number of distinct operators \\(n2\\) = the number of distinct operands \\(N1\\) = the total number of operators \\(N2\\) = the total number of operands From these numbers, eight measures can be calculated: Program vocabulary: \\(n = n1 + n2\\) Program length: \\(N = N1 + N2\\) Calculated program length: \\(N' = n1 * log2(n1) + n2 * log2(n2)\\) Volume: \\(V = N * log2(n)\\) Difficulty: \\(D = (n1/2) * (N2/n2)\\) Effort: \\(E = D * V\\) Time required to program: \\(T = E / 18 seconds\\) Number of delivered bugs: \\(B = V / 3000\\) Note https://en.wikipedia.org/wiki/Halstead_complexity_measures https://www.verifysoft.com/en_halstead_metrics.html","title":"Halstead complexity measures"},{"location":"metrics/#cyclomatic-complexity-number-and-weighted-method-count","text":"Metrics: wmc , ccn , ccnMethodMax The cyclomatic complexity ( \\(CCN\\) ) is a measure of control structure complexity of a function or procedure. We can calculate ccn in two ways (we choose the second): \\[ (CCN) = E - N + 2P \\] Where: \\(P\\) = number of disconnected parts of the flow graph (e.g. a calling program and a subroutine) \\(E\\) = number of edges (transfers of control) \\(N\\) = number of nodes (sequential group of statements containing only one transfer of control) OR \\(CCN\\) = Number of each decision point The weighted method count ( \\(WMC\\) ) is count of methods parameterized by a algorithm to compute the weight of a method. Given a weight metric \\(w\\) and methods \\(m\\) it can be computed as sum m(w') over (w' in w) Possible algorithms are: Cyclomatic Complexity Lines of Code 1 (unweighted WMC) This visitor provides two metrics, the maximal CCN of all methods from one class (currently stored as ccnMethodMax) and the WMC using the CCN as weight metric (currently stored as ccn). Note https://en.wikipedia.org/wiki/Cyclomatic_complexity http://www.literateprogramming.com/mccabe.pdf https://www.pitt.edu/~ckemerer/CK%20research%20papers/MetricForOOD_ChidamberKemerer94.pdf","title":"Cyclomatic complexity number and weighted method count"},{"location":"metrics/#kans-defects","text":"Metrics: kanDefect \\(kanDefect = 0.15 + 0.23\\) * number of do\u2026while() + $0.22 $ * number of switch() + \\(0.07\\) * number of if()","title":"Kan's defects"},{"location":"metrics/#maintainability-index","text":"Metrics: mi , mIwoC , commentWeight According to Wikipedia, \"Maintainability Index is a software metric which measures how maintainable (easy to support and change) the source code is. The maintainability index is calculated as a factored formula consisting of Lines Of Code, Cyclomatic Complexity and Halstead volume.\" \\(mIwoC\\) : Maintainability Index without comments \\(MIcw\\) : Maintainability Index comment weight$ \\(mi\\) : Maintainability Index = \\(mi = MIwoc + MIcw\\) \\(MIwoc = 171 - 5.2 * ln(aveV) -0.23 * aveG -16.2 * ln(aveLOC)\\) \\(MIcw** = 50 * sin(sqrt(2.4 * perCM))\\) \\(mi = MIwoc + MIcw\\) Note https://www.verifysoft.com/en_maintainability.html","title":"Maintainability Index"},{"location":"metrics/#lack-of-cohesion-of-methods","text":"Metrics: lcom Cohesion metrics measure how well the methods of a class are related to each other. A cohesive class performs one function while a non-cohesive class performs two or more unrelated functions. A non-cohesive class may need to be restructured into two or more smaller classes. High cohesion is desirable since it promotes encapsulation. As a drawback, a highly cohesive class has high coupling between the methods of the class, which in turn indicates high testing effort for that class. Low cohesion indicates inappropriate design and high complexity. It has also been found to indicate a high likelihood of errors. The class should probably be split into two or more smaller classes. Note https://blog.ndepend.com/lack-of-cohesion-methods/ http://www.arisa.se/compendium/node116.html","title":"Lack of cohesion of methods"},{"location":"metrics/#card-and-agresti-metric","text":"Metrics: relativeStructuralComplexity , relativeDataComplexity , relativeSystemComplexity , totalStructuralComplexity , totalDataComplexity , totalSystemComplexity \\(Fan-out\\) = Structural fan-out = Number of other procedures this procedure calls \\(v\\) = number of input/output variables for a procedure ( \\(SC\\) ) Structural complexity \\(SC = fan-out^2\\) ( \\(DC\\) ) Data complexity \\(DC = v / (fan-out + 1)\\) Note https://www.witpress.com/Secure/elibrary/papers/SQM94/SQM94024FU.pdf","title":"Card and Agresti metric"},{"location":"metrics/#length","text":"Metrics: cloc , loc , lloc \\(loc\\) : lines count \\(cloc\\) : lines count without multiline comments \\(lloc\\) : lines count without empty lines","title":"Length"},{"location":"metrics/#methods","text":"Metrics : nbMethodsIncludingGettersSetters , nbMethods , nbMethodsPrivate , nbMethodsPublic , nbMethodsGetter , nbMethodsSetters","title":"Methods"},{"location":"metrics/#coupling","text":"Metrics: afferentCoupling , efferentCoupling , instability Afferent couplings ($Ca): The number of classes in other packages that depend upon classes within the package is an indicator of the package's responsibility. Efferent couplings ( \\(Ce\\) ): The number of classes in other packages that the classes in a package depend upon is an indicator of the package's dependence on externalities. Instability ( \\(I\\) ): The ratio of efferent coupling ( \\(Ce\\) ) to total coupling ( \\(Ce + Ca\\) ) such that \\(I = Ce / (Ce + Ca)\\) . Note https://www.future-processing.pl/blog/object-oriented-metrics-by-robert-martin/ https://en.wikipedia.org/wiki/Software_package_metrics","title":"Coupling"},{"location":"metrics/#depth-of-inheritance-tree","text":"Metrics: depthOfInheritanceTree Measures the length of inheritance from a class up to the root class.","title":"Depth of inheritance tree"},{"location":"metrics/#page-rank","text":"Metrics: pageRank The first version of the PageRank algorithm was developed by Larry Page and Sergey Brin in 1998. The algorithm is used to rank web pages according to their importance. We applied the PageRank algorithm to the case of relationships between packages and classes.","title":"Page rank"}]}